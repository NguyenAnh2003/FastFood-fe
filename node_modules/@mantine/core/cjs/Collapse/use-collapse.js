'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var reactDom = require('react-dom');
var hooks = require('@mantine/hooks');

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
function getAutoHeightDuration(height) {
  if (!height || typeof height === "string") {
    return 0;
  }
  const constant = height / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function getElementHeight(el) {
  return (el == null ? void 0 : el.current) ? el.current.scrollHeight : "auto";
}
function getElementWidth(el) {
  return (el == null ? void 0 : el.current) ? el.current.scrollWidth : "auto";
}
const raf = typeof window !== "undefined" && window.requestAnimationFrame;
function useCollapse({
  transitionDuration,
  transitionTimingFunction = "ease",
  onTransitionEnd = () => {
  },
  opened,
  axis
}) {
  const el = React.useRef(null);
  const collapsedHeight = "0px";
  const [styles, setStylesRaw] = React.useState({});
  const setStyles = (newStyles) => {
    reactDom.flushSync(() => setStylesRaw(newStyles));
  };
  const mergeStyles = (newStyles) => {
    setStyles((oldStyles) => __spreadValues(__spreadValues({}, oldStyles), newStyles));
  };
  function getTransitionStyles(height) {
    const _duration = transitionDuration || getAutoHeightDuration(height);
    return {
      transitionProperty: `${axis === "x" ? "width" : "height"}`,
      transitionDuration: `${_duration}ms`,
      transitionTimingFunction: `${transitionTimingFunction}`
    };
  }
  const getDefaultSizes = () => {
    const oldStyles = styles;
    setStyles({});
    const sizes = { width: getElementWidth(el), height: getElementHeight(el) };
    setStyles(oldStyles);
    return sizes;
  };
  const getCollapsedStyles = () => {
    const { height } = getDefaultSizes();
    return {
      x: { height, width: "0px", overflow: "hidden" },
      y: { display: "none", height: "0px", overflow: "hidden" }
    };
  };
  React.useEffect(() => {
    raf(() => {
      const { x, y } = getCollapsedStyles();
      if (axis === "x" && !opened) {
        setStyles(__spreadValues({}, x));
      } else if (axis === "y" && !opened) {
        setStyles(__spreadValues({}, y));
      }
    });
  }, []);
  hooks.useDidUpdate(() => {
    if (axis === "x")
      return;
    if (opened) {
      raf(() => {
        mergeStyles({ willChange: "height", display: "block", overflow: "hidden" });
        raf(() => {
          const height = getElementHeight(el);
          mergeStyles(__spreadProps(__spreadValues({}, getTransitionStyles(height)), { height }));
        });
      });
    } else {
      raf(() => {
        const height = getElementHeight(el);
        mergeStyles(__spreadProps(__spreadValues({}, getTransitionStyles(height)), { willChange: "height", height }));
        raf(() => mergeStyles({ height: collapsedHeight, overflow: "hidden" }));
      });
    }
  }, [opened]);
  hooks.useDidUpdate(() => {
    if (axis === "y")
      return;
    if (opened) {
      raf(() => {
        const { width } = getDefaultSizes();
        mergeStyles({
          display: "block",
          overflow: "hidden",
          willChange: "width",
          flexShrink: 0
        });
        raf(() => {
          mergeStyles(__spreadProps(__spreadValues({}, getTransitionStyles(width)), { width }));
        });
      });
    } else {
      raf(() => {
        const { width, height } = getDefaultSizes();
        mergeStyles(__spreadProps(__spreadValues({}, getTransitionStyles(width)), {
          flexShrink: 0,
          willChange: "width",
          width,
          height
        }));
        raf(() => mergeStyles({ width: "0px", overflow: "hidden" }));
      });
    }
  }, [opened]);
  const handleTransitionEnd = (e) => {
    if (e.target !== el.current || !(e.propertyName === "width" || "height")) {
      return;
    }
    onTransitionEnd();
    if (opened) {
      setStyles({});
    } else {
      const { x, y } = getCollapsedStyles();
      if (axis === "x")
        setStyles(x);
      else
        setStyles(y);
    }
  };
  function getCollapseProps(_a = {}) {
    var _b = _a, { style = {}, refKey = "ref" } = _b, rest = __objRest(_b, ["style", "refKey"]);
    const theirRef = rest[refKey];
    return __spreadProps(__spreadValues({
      "aria-hidden": !opened
    }, rest), {
      [refKey]: hooks.mergeRefs(el, theirRef),
      onTransitionEnd: handleTransitionEnd,
      style: __spreadValues(__spreadValues({ boxSizing: "border-box" }, style), styles)
    });
  }
  return getCollapseProps;
}

exports.getElementHeight = getElementHeight;
exports.getElementWidth = getElementWidth;
exports.useCollapse = useCollapse;
//# sourceMappingURL=use-collapse.js.map
